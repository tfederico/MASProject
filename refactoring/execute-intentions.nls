; Execute the action get-schedule: the agent needs to retrieve its schedule
to execute-get-schedule 
  ifelse is-at-least-role "coordinator" [
   set beliefs (get-schedule-from-id-without-three 0)
  ][
   ; The bus is not a coordinator
   ; Get the list of messages regarding the schedules
   let msgs (get-msgs-with-header-id (inbox) 0)
   ; If we received the schedule, assign it to the bus
   if not empty? msgs [
    let sched_id read-from-string (extract-message (item 2 (item 0 msgs)))
    set beliefs (get-schedule-from-id-without-three sched_id)  
   ]  
  ]
  ; If we managed to obtain a schedule, add the end station of the schedule and remove the intention of getting a schedule
  if not empty? beliefs [ 
    set beliefs lput 3 beliefs 
    set intentions butfirst intentions 
    set running true
  ]
end

; Execute the action send-initial-schedules: at the beginning, the coordinator sends the schedules to the local coordinators and the scouts
to execute-send-initial-schedules
  let index 1
  ; Send the schedules to the local coordinators
  foreach local_coordinators [ lc ->
    if coordinator != lc [
      send-message lc (word "schedule " index)
      set index (index + 1)
    ]
  ]
  ; Send the schedules to the scouts
  foreach scouts [ s ->
    send-message s (word "schedule " index)
    set index (index + 1)
  ]
  set intentions butfirst intentions
end

; The bus drops all the passengers that are in their destination (or the passengers that needs to go to another schedule and the current stop is a joint position)
to execute-drop-passengers
  ; Get the list of arrived passengers and drop them
  let arrived_passengers (filter [ passenger -> (at-destination passenger or at-joint-position passenger)] bus_passengers)
  foreach arrived_passengers [ passenger -> drop-off-passenger (item 0 passenger) ]
  ; Remove the intentions from the list
  set intentions butfirst intentions
end

; Check whether the bus can stop or not in order to save money
to execute-check-stop
  ; 1) Every kind of bus (i.e., every role) stops if there are no more people waiting in its area and the bus is empty
  ; 2) The simple buses stops if they are empty and they reach a station which is also empty
  
  let people-waiting-in-area get-people-waiting-in-my-area
  let is-empty (get-available-spots = get-capacity-from-type bus_type)
  
  if (people-waiting-in-area = 0 and is-empty) or (is-empty and role = "simple" and get-passengers-at-stop current_stop = 0)[
   set running false 
  ]
  set intentions butfirst intentions
end

; Check wheter the bus has to restart after stopping
to execute-check-restart
  ; 1) Every kind of bus (i.e., every role) restarts if there are people waiting in its area
  let people-waiting-in-area get-people-waiting-in-my-area
  if people-waiting-in-area != 0 [
   set running true
   set intentions butfirst intentions 
  ]
  
end

; Pick all the passengers that are convenient to pick up, considering the direction of the bus and the passenger destination
to execute-pick-passengers
  foreach get-passengers-at-stop current_stop [ passenger ->
    if ((need-to-pick passenger) and get-available-spots > 0 and (is-correct-direction (item 1 passenger))) [
     pick-up-passenger (item 0 passenger) 
    ]
  ]
  
  ; Remove the intentions from the list
  set intentions butfirst intentions
end

; Checks the number of people waiting compared to the number of buses: if the buses are not enough, call new buses
to execute-check-amount-people
  ; Only the coordinator can create new buses
  if is-at-least-role "coordinator" [
    ; Compute the difference between the number of passengers waiting and the capacity of the fleet, as a danger measure
    let diff (amount_passengers_waiting - total_capacity)
    let d diff
    ; While we do not have enough buses to manage the danger situation, create new buses
    while [ diff > 0] [ 
      set diff (create-buses-from-diff diff) 
    ]
    ; If I have created new buses, send a bid request
    if d != diff [ send-bid-requests ]
  ]
  set intentions butfirst intentions
end

; Travel to the next stop
to execute-travel
  let intention (item 0 intentions)
  ifelse current_stop = intention [ 
    set intentions butfirst intentions
  ] [
    travel-to intention
  ]
end

; Tell to the coordinator the situation of your area, trying to obtain new buses
to execute-bid
  ; As a first instance, we are using as bid a danger situation for the area, that is the number of people waiting in my area
  let bid get-people-waiting-in-my-area
  send-message coordinator (word "bid " bid)  
  set intentions butfirst intentions
end

to execute-assign-new-buses
  assign-buses
  set intentions butfirst intentions
end