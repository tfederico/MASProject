buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  desire
  intentions
  beliefs
  
  capacity
  roles ; "coordinator" "scout" "simple"
  running ; true or false, whether the bus has to stop or not
  last-created-bus ; id of the last created bus. Only the coordinator updates this value
  last-inbox-check ; tick in which the agent checked for the last time the inbox 
  last-wake-sent ; tick in which the coordinator sent the last wake up message
  tot-capacity ; total capacity of the bus fleet. Only the coordinator keeps track of this value, the other receive this value as a message  
  last-promote-all ; last global promotion done by the coordinator
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  init-desire
  init-intentions
  init-beliefs
  init-capacity
end

to init-desire
  set desire "transport-passengers"
end

to init-intentions
  set intentions []
end

to-report get-schedule
  let schedule [];[9 8 6 8 2 8 9 3 20 12 15 18 15 12 20 21 22 0 14 23 19 1 7 13 10 17 11 16 5 4]
  let schedule_1 [ 16 11 1 7 17 5 4 ]
  let schedule_2 [ 9 8 2 8 6 8 9 ]
  let schedule_3 [ 4 10 13 23 14 23 19 1 7 17 5 4 ]
  let schedule_4 [ 20 12 15 18 15 0 22 21 20 ]
  let schedules []
  set schedules lput schedule_1 schedules
  set schedules lput schedule_2 schedules
  set schedules lput schedule_3 schedules
  set schedules lput schedule_4 schedules
  set schedules lput (reverse schedule_1) schedules
  set schedules lput (reverse schedule_2) schedules
  set schedules lput (reverse schedule_3) schedules
  set schedules lput (reverse schedule_4) schedules
  set schedule (item (bus_id mod 8) schedules)     
  set schedule fput 3 schedule
  report schedule
end

to init-beliefs
  set beliefs get-schedule ; Insert fixed schedule here 
end

to init-capacity 
  if bus_type = 1 [
    set capacity bus_type1_capacity
  ]
  if bus_type = 2 [
    set capacity bus_type2_capacity
  ]
  if bus_type = 3 [
    set capacity bus_type3_capacity
  ]
end

to-report get-available-spots
  ifelse is-turtle? self = false [
    show (word "ERROR: get-available-spot is a command for a bus")
    report -1 
  ] [
   report (capacity - (length bus_passengers)) 
  ]
end

to wrap-add-bus [bustype] 
  ; wrapper to the add-bus function
  add-bus bustype
  set last-created-bus (last-created-bus + 1)
  let new-capacity bus_type1_capacity
  if bustype = 2 [
    set new-capacity bus_type2_capacity  
  ]
  if bustype = 3 [
    set new-capacity bus_type3_capacity 
  ]
  set tot-capacity (tot-capacity + new-capacity)
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  if roles = 0[
    ifelse bus_id = 24 [ 
      set roles ["coordinator" "scout"]
      set last-created-bus 24
      set tot-capacity bus_type1_capacity
    ][ 
      ifelse bus_id > 24 and bus_id < 32 [ 
        set roles ["scout"] 
      ] [
        set roles ["simple"]  
      ]
    ]
    set running true
  ]
  
  ; creating the first 7 buses (+1 original bus) 
  if ticks = 2 and member? "coordinator" roles [
    let counter 0
    while [counter < 7] [
      wrap-add-bus 1
      set counter (counter + 1) ]
  ]
  update-beliefs
  update-desire
  update-intentions
  
  let intention (item 0 intentions)
  
  ; checking intentions and executing actions
  if intention = "check-inbox" [
    let new-messages (filter [m -> ((item 0 m) >= last-inbox-check and (item 0 m) != ticks) ] inbox)
    set last-inbox-check ticks
    foreach new-messages [ m ->
      if (item 2 m) = "scout" [
        if not member? "scout" roles [ set roles lput "scout" roles ]
        if member? "simple" roles [ set roles remove "simple" roles ]
      ]
      if (item 2 m) = "simple" [
        set roles [ "simple" ] 
      ]
      
    ] 
    set intentions but-first intentions
    set intention (item 0 intentions)  
  ]
  
  if intention = "check-restart" [
    let num-passengers amount_passengers_waiting
    let c-global-passengers num-passengers > 2000 ; temporary threshold
    let c-current-stop ((length (get-passengers-at-stop current_stop)) != 0 )
    let c-already-running running  
    let restart-condition (c-global-passengers or c-current-stop or c-already-running) 
    if restart-condition [
      wrap-running
      set intentions but-first intentions
      set intention (item 0 intentions)
    ]
  ]
  
  if running = false [
   stop 
  ]
  
  if intention = "manage-passengers" [
    drop-arrived-passengers
    pick-passengers 
  ]
  
  if intention = "check-stop" [
    if get-available-spots = capacity and (length (get-passengers-at-stop current_stop)) = 0 [
      set running false 
    ] 
  ]
  
  if intention = "check-amount-people" [
   ; get the number of people of the stop
   let num-passengers amount_passengers_waiting
   ; if necessary, ask for a new bus 
   let diff (num-passengers - tot-capacity)
   if diff > bus_type2_capacity [
     promote-all "scout"   
   ]
   if diff <= 0 and last-promote-all = "scout" [
      promote-all "simple"
    ]
   while [diff > 0] [
     ifelse diff > bus_type2_capacity [
        wrap-add-bus 3  
        set diff (diff - bus_type3_capacity) 
      ] [
       ifelse diff > bus_type1_capacity [
         wrap-add-bus 2
         set diff (diff - bus_type2_capacity) 
       ] [
         wrap-add-bus 1
         set diff (diff - bus_type1_capacity)  
       ]   
     ] 
   ]
  ]
  
  if is-number? intention [
   travel-to intention
  ]
end

to promote-all [role]
  ; promoting/demoting all the buses with id over 32 to a specific role
  let c 32
  while [ c <= last-created-bus] [
   send-message c role
   set c (c + 1) 
  ]
  set last-promote-all role
end

to wrap-running
  if running = false [ 
    set running true
    set intentions fput "manage-passengers" intentions
  ] 
end

to drop-arrived-passengers
  ; get the list of arrived passengers and drop them
  
  let arrived-passengers (filter [ passenger -> (check-arrival passenger)] bus_passengers)
  foreach arrived-passengers [ passenger -> drop-off-passenger (item 0 passenger) ]
end

to-report check-arrival [passenger]
  ; function used to check if the passenger is in the correct stop
  let schedule beliefs
  let joint-pos get-joint-pos
  let arrived-condition ((item 1 passenger) = current_stop)
  let other-area-condition (not member?(item 1 passenger) schedule) and (member? current_stop joint-pos)
  report (arrived-condition or other-area-condition)
end

to pick-passengers
  ; function used to decide which are the passenger to pick up
  let joint-pos get-joint-pos
  foreach get-passengers-at-stop current_stop [
    passenger -> 
      if ((need-to-pick passenger) and get-available-spots > 0 and (is-correct-direction (item 1 passenger))) [ 
        pick-up-passenger (item 0 passenger) 
      ]
  ] 
end

to-report need-to-pick [passenger]
  ; 1) dest is in my area no matter what I am
  ; 2) dest is not in my area and the current pos is not a join
  report destination-in-my-area passenger or ((not destination-in-my-area passenger) and (not in-joint))
end

to-report destination-in-my-area [passenger]
  ; fuction used to check if the destination of a specific passenger is in the schedule of the bus
  let destination (item 1 passenger)
  let schedule beliefs
  report member? destination schedule
end

to-report in-joint
  let joint-pos get-joint-pos
  report member? current_stop joint-pos
end

to-report get-joint-pos
  ; function used to retrieve the stops used as joints between different schedule
  report [3]
end

to-report is-correct-direction [destination]
  ; function used to understand if a specific bus stop is closer to this schedule respect to the reverse one
  let schedule beliefs
  if not member? destination schedule [
    set destination (get-nearest-joint) 
  ]
  report (position destination schedule) < ((length schedule) / 2)
end

to-report get-nearest-joint
  ; function used to 
  let joint-pos get-joint-pos
  report (item 0 joint-pos)
end
  
to update-beliefs
  ; if first stop of schedule is where the agent is, then move the first element of the list to the end
  if current_stop = item 0 beliefs [
    let tmp (item 0 beliefs)
    set beliefs (but-first beliefs)
    set beliefs lput tmp beliefs
  ]
end

to update-desire
  ; for now there is a single desire, so no updates
end

to update-intentions
  ; function used to add the new intentions
  if desire = "transport-passengers" [
    ifelse empty? intentions [
      set intentions lput "manage-passengers" intentions
      if member? "coordinator" roles [ set intentions lput "check-amount-people" intentions ]
      add-newstop-intentions 
    ] [
      let intention item 0 intentions
      
      if is-number? intention [
        if current_stop = intention [
          set intentions but-first intentions
          add-newstop-intentions
        ] 
      ]
      if intention = "manage-passengers" or intention = "check-amount-people" [
        ; assuming that the environment is deterministic
        set intentions but-first intentions 
      ] 
      if intention = "check-stop" [
        set intentions but-first intentions
      ]
    ]
  ]
end

to add-newstop-intentions
  ; function used to add the intention for a new bus stop and the management of passengers
  set intentions lput (item 0 beliefs) intentions
  set intentions lput "manage-passengers" intentions
  if member? "coordinator" roles [ set intentions lput "check-amount-people" intentions ]
  if member? "simple" roles [ 
    set intentions lput "check-stop" intentions 
    set intentions lput "check-restart" intentions 
  ]
  set intentions lput "check-inbox" intentions
end

